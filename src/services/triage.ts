import * as core from '@actions/core';
import {
  Config,
  IssueEvent,
  PullRequestEvent,
  SimilarItem,
  StorageBackend,
  VisionAlignment,
} from '../types';
import { LLMService } from './llm';
import { GitHubService } from './github';
import { scoreBacklogItem, type BacklogScore } from '../utils/scoring';

type DedupeStatus = 'duplicate' | 'related' | 'distinct';
type BacklogItemType = 'issue' | 'pr';

export interface BacklogItem {
  type: BacklogItemType;
  number: number;
  title: string;
  url: string;
  dedupeStatus: DedupeStatus;
  similarity: number;
  score: number;
  reasons: string[];
}

interface SeverityCount {
  critical: number;
  major: number;
  minor: number;
  info: number;
}

interface ScoringInputs {
  type: BacklogItemType;
  dedupeStatus: DedupeStatus;
  similarity: number;
  visionAlignment?: VisionAlignment;
  reviewComplexity?: 'low' | 'medium' | 'high';
  severityCounts?: SeverityCount;
}

export class TriageService {
  private llm: LLMService;
  private github: GitHubService;

  constructor(
    private config: Config,
    private storage: StorageBackend
  ) {
    this.llm = new LLMService(config);
    this.github = new GitHubService(config);
  }

  /**
   * Process an issue event
   */
  async processIssue(event: IssueEvent): Promise<void> {
    const { issue, repository } = event;
    const [owner, repo] = repository.full_name.split('/');

    core.info(`Processing issue #${issue.number}: ${issue.title}`);

    const tasks: Promise<void>[] = [];

    if (this.config.enableDuplicateDetection) {
      tasks.push(this.detectIssueDuplicate(owner, repo, issue));
    }

    if (this.config.enableLabeling) {
      tasks.push(this.suggestIssueLabels(owner, repo, issue));
    }

    await Promise.all(tasks);
  }

  /**
   * Process a pull request event
   */
  async processPullRequest(event: PullRequestEvent): Promise<void> {
    const { pull_request, repository } = event;
    const [owner, repo] = repository.full_name.split('/');

    core.info(`Processing PR #${pull_request.number}: ${pull_request.title}`);

    const tasks: Promise<void>[] = [];

    if (this.config.enableDuplicateDetection) {
      tasks.push(this.detectPrDuplicate(owner, repo, pull_request));
    }

    if (this.config.enablePrReview) {
      tasks.push(this.generatePrReview(owner, repo, pull_request));
    }

    if (this.config.enableLabeling) {
      tasks.push(this.suggestPrLabels(owner, repo, pull_request));
    }

    await Promise.all(tasks);
  }

  /**
   * Process a backlog scan for open issues and PRs.
   * Returns ranked items with score reasoning.
   */
  async processBacklog(owner: string, repo: string): Promise<BacklogItem[]> {
    const limit = this.config.backlogLimit ?? 200;

    core.info(`Running backlog scan for ${owner}/${repo} (limit=${limit})`);

    const [issues, prs] = await Promise.all([
      this.github.getIssues(owner, repo, 'open'),
      this.github.getPullRequests(owner, repo, 'open'),
    ]);

    const scanned = await Promise.all([
      ...issues.slice(0, limit).map((issue: any) => this.evaluateIssueForBacklog(owner, repo, issue)),
      ...prs.slice(0, Math.max(0, limit - issues.length)).map((pr: any) => this.evaluatePrForBacklog(owner, repo, pr)),
    ]);

    return scanned
      .filter((item): item is BacklogItem => Boolean(item))
      .sort((a, b) => b.score - a.score);
  }

  public buildBacklogReport(items: BacklogItem[]): string {
    if (items.length === 0) {
      return 'No open issues or pull requests need immediate attention from this scan.';
    }

    const issues = items.filter(item => item.type === 'issue');
    const prs = items.filter(item => item.type === 'pr');
    const formatList = (rows: BacklogItem[]) => rows
      .map(item => `- [#${item.number}](${item.url}) ${item.title} ‚Äî score ${item.score} (${item.dedupeStatus}, ${(item.similarity * 100).toFixed(1)}%)`)
      .join('\n');

    let body = '## PRism backlog scan\n\n';
    body += 'Prioritized open issues and PRs:\n\n';

    if (issues.length > 0) {
      body += '### Issues\n';
      body += `${formatList(issues)}\n\n`;
    }

    if (prs.length > 0) {
      body += '### Pull Requests\n';
      body += `${formatList(prs)}\n\n`;
    }

    body += `Generated by PRism on ${new Date().toISOString()}.`;
    return body;
  }

  async postBacklogReport(owner: string, repo: string, issueNumber: number, items: BacklogItem[]): Promise<void> {
    const report = this.buildBacklogReport(items);
    await this.github.postIssueComment(owner, repo, issueNumber, report);
  }

  /**
   * Detect duplicate issues
   */
  private async detectIssueDuplicate(
    owner: string,
    repo: string,
    issue: IssueEvent['issue']
  ): Promise<void> {
    try {
      core.info(`Checking for duplicate issues for #${issue.number}`);

      const text = `${issue.title}\n\n${issue.body || ''}`;
      const embedding = await this.llm.generateEmbedding(text);
      await this.storage.storeEmbedding(`issue-${issue.number}`, embedding);
      const similarItems = await this.findSimilarIssues(owner, repo, embedding, issue.number);

      if (similarItems.length === 0) {
        core.info('No similar issues found');
        return;
      }

      const similarIssuesWithBody = await Promise.all(
        similarItems.slice(0, 5).map(async (item) => {
          const fullIssue = await this.github.getIssue(owner, repo, item.number);
          return {
            number: item.number,
            title: item.title,
            body: fullIssue.body || '',
            url: item.url,
            similarity: item.similarity,
          };
        })
      );

      const result = await this.llm.detectDuplicate(issue.title, issue.body || '', similarIssuesWithBody);

      if (result.isDuplicate && result.similarItems.length > 0) {
        const comment = this.formatDuplicateComment(result, 'issue');
        await this.github.postIssueComment(owner, repo, issue.number, comment);
        core.info(`Posted duplicate detection comment for issue #${issue.number}`);
      } else {
        core.info('Issue is not a duplicate');
      }
    } catch (error) {
      core.error(`Error detecting duplicate issue: ${error}`);
    }
  }

  /**
   * Detect duplicate PRs
   */
  private async detectPrDuplicate(
    owner: string,
    repo: string,
    pr: PullRequestEvent['pull_request']
  ): Promise<void> {
    try {
      core.info(`Checking for duplicate PRs for #${pr.number}`);

      const text = `${pr.title}\n\n${pr.body || ''}`;
      const embedding = await this.llm.generateEmbedding(text);
      await this.storage.storeEmbedding(`pr-${pr.head.sha}`, embedding);
      const similarItems = await this.findSimilarPrs(owner, repo, embedding, pr.number);

      if (similarItems.length === 0) {
        core.info('No similar PRs found');
        return;
      }

      const similarPrsWithBody = await Promise.all(
        similarItems.slice(0, 5).map(async (item) => {
          const fullPr = await this.github.getPullRequest(owner, repo, item.number);
          return {
            number: item.number,
            title: item.title,
            body: fullPr.body || '',
            url: item.url,
            similarity: item.similarity,
          };
        })
      );

      const result = await this.llm.detectDuplicate(pr.title, pr.body || '', similarPrsWithBody);

      if (result.isDuplicate && result.similarItems.length > 0) {
        const comment = this.formatDuplicateComment(result, 'pr');
        await this.github.postPullRequestComment(owner, repo, pr.number, comment);
        core.info(`Posted duplicate detection comment for PR #${pr.number}`);
      } else {
        core.info('PR is not a duplicate');
      }
    } catch (error) {
      core.error(`Error detecting duplicate PR: ${error}`);
    }
  }

  /**
   * Generate PR review
   */
  private async generatePrReview(
    owner: string,
    repo: string,
    pr: PullRequestEvent['pull_request']
  ): Promise<void> {
    try {
      core.info(`Generating review for PR #${pr.number}`);

      const [diff, files] = await Promise.all([
        this.github.getPullRequestDiff(owner, repo, pr.number),
        this.github.getPullRequestFiles(owner, repo, pr.number),
      ]);

      const review = await this.llm.generatePrReview(
        pr.title,
        pr.body || '',
        diff,
        files.map((f: { filename: string; additions: number; deletions: number }) => ({
          filename: f.filename,
          additions: f.additions,
          deletions: f.deletions,
        }))
      );

      const comment = this.formatReviewComment(review);
      await this.github.postPullRequestComment(owner, repo, pr.number, comment);
      core.info(`Posted review comment for PR #${pr.number}`);

      if (this.config.enableLabeling && review.suggestedLabels.length > 0) {
        const repoLabels = await this.github.getRepositoryLabels(owner, repo);
        const validLabels = review.suggestedLabels.filter(label => repoLabels.includes(label));
        if (validLabels.length > 0) {
          await this.github.addLabels(owner, repo, pr.number, validLabels);
          core.info(`Applied labels to PR #${pr.number}: ${validLabels.join(', ')}`);
        }
      }
    } catch (error) {
      core.error(`Error generating PR review: ${error}`);
    }
  }

  /**
   * Suggest labels for an issue
   */
  private async suggestIssueLabels(
    owner: string,
    repo: string,
    issue: IssueEvent['issue']
  ): Promise<void> {
    try {
      core.info(`Suggesting labels for issue #${issue.number}`);

      const repoLabels = await this.github.getRepositoryLabels(owner, repo);
      const suggestion = await this.llm.suggestLabels(issue.title, issue.body || '', 'issue', repoLabels);

      const validLabels = suggestion.labels.filter(label => repoLabels.includes(label));
      if (validLabels.length > 0) {
        await this.github.addLabels(owner, repo, issue.number, validLabels);
        core.info(`Applied labels to issue #${issue.number}: ${validLabels.join(', ')}`);
      }
    } catch (error) {
      core.error(`Error suggesting labels for issue: ${error}`);
    }
  }

  /**
   * Suggest labels for a PR
   */
  private async suggestPrLabels(
    owner: string,
    repo: string,
    pr: PullRequestEvent['pull_request']
  ): Promise<void> {
    try {
      core.info(`Suggesting labels for PR #${pr.number}`);

      const repoLabels = await this.github.getRepositoryLabels(owner, repo);
      const suggestion = await this.llm.suggestLabels(pr.title, pr.body || '', 'pr', repoLabels);

      const validLabels = suggestion.labels.filter(label => repoLabels.includes(label));
      if (validLabels.length > 0) {
        await this.github.addLabels(owner, repo, pr.number, validLabels);
        core.info(`Applied labels to PR #${pr.number}: ${validLabels.join(', ')}`);
      }
    } catch (error) {
      core.error(`Error suggesting labels for PR: ${error}`);
    }
  }

  /**
   * Evaluate one issue in backlog scan
   */
  private async evaluateIssueForBacklog(owner: string, repo: string, issue: any): Promise<BacklogItem | null> {
    const text = `${issue.title}\n\n${issue.body || ''}`;
    const embedding = await this.llm.generateEmbedding(text);
    await this.storage.storeEmbedding(`issue-${issue.number}`, embedding);

    const similarItems = await this.findSimilarIssues(owner, repo, embedding, issue.number, 'open');
    const duplicateResult = await this.resolveDuplicateStatus(owner, repo, issue.title, issue.body || '', similarItems);

    const score = this.scoreBacklogEntry({
      type: 'issue',
      dedupeStatus: duplicateResult.status,
      similarity: duplicateResult.similarity,
    });

    return {
      type: 'issue',
      number: issue.number,
      title: issue.title,
      url: issue.html_url,
      dedupeStatus: duplicateResult.status,
      similarity: duplicateResult.similarity,
      score: score.score,
      reasons: score.reasons,
    };
  }

  /**
   * Evaluate one PR in backlog scan
   */
  private async evaluatePrForBacklog(owner: string, repo: string, pr: any): Promise<BacklogItem | null> {
    const text = `${pr.title}\n\n${pr.body || ''}`;
    const embedding = await this.llm.generateEmbedding(text);
    await this.storage.storeEmbedding(`pr-${pr.head.sha}`, embedding);

    const similarItems = await this.findSimilarPrs(owner, repo, embedding, pr.number, 'open');
    const duplicateResult = await this.resolveDuplicateStatus(owner, repo, pr.title, pr.body || '', similarItems);

    let visionAlignment: VisionAlignment | undefined;
    let review: {
      findings: Array<{ type: string; severity: 'critical' | 'major' | 'minor' | 'info' }>;
      estimatedComplexity: 'low' | 'medium' | 'high';
      summary: string;
    } | null = null;
    const scoringInputs: ScoringInputs = {
      type: 'pr',
      dedupeStatus: duplicateResult.status,
      similarity: duplicateResult.similarity,
    };

    if (this.config.enablePrReview) {
      try {
        const [diff, files] = await Promise.all([
          this.github.getPullRequestDiff(owner, repo, pr.number),
          this.github.getPullRequestFiles(owner, repo, pr.number),
        ]);
        review = await this.llm.generatePrReview(
          pr.title,
          pr.body || '',
          diff,
          files.map((f: { filename: string; additions: number; deletions: number }) => ({
            filename: f.filename,
            additions: f.additions,
            deletions: f.deletions,
          }))
        );
      } catch (error) {
        core.error(`Backlog review generation failed for PR #${pr.number}: ${error}`);
      }
    }

    if (review) {
      scoringInputs.reviewComplexity = review.estimatedComplexity;
      scoringInputs.severityCounts = this.getSeverityCounts(review.findings || []);
      if (this.config.visionDocument) {
        visionAlignment = await this.llm.assessVisionAlignment(pr.title, pr.body || '', this.config.visionDocument, review.summary);
        scoringInputs.visionAlignment = visionAlignment;
      }
    }

    const scored = this.scoreBacklogEntry(scoringInputs);

    return {
      type: 'pr',
      number: pr.number,
      title: pr.title,
      url: pr.html_url,
      dedupeStatus: duplicateResult.status,
      similarity: duplicateResult.similarity,
      score: scored.score,
      reasons: scored.reasons,
    };
  }

  private getSeverityCounts(findings: Array<{ severity?: 'critical' | 'major' | 'minor' | 'info' }>): SeverityCount {
    const severityCounts: SeverityCount = { critical: 0, major: 0, minor: 0, info: 0 };
    for (const finding of findings) {
      if (finding.severity === 'critical') {
        severityCounts.critical += 1;
      } else if (finding.severity === 'major') {
        severityCounts.major += 1;
      } else if (finding.severity === 'minor') {
        severityCounts.minor += 1;
      } else if (finding.severity === 'info') {
        severityCounts.info += 1;
      }
    }
    return severityCounts;
  }

  private async resolveDuplicateStatus(
    owner: string,
    repo: string,
    title: string,
    body: string,
    similarItems: SimilarItem[]
  ): Promise<{ status: DedupeStatus; similarity: number }> {
    if (similarItems.length === 0 || !this.config.enableDuplicateDetection) {
      return { status: 'distinct', similarity: 0 };
    }

    const similarWithBody = await Promise.all(
      similarItems.slice(0, 5).map(async (item) => {
        const source = item.type === 'issue'
          ? await this.github.getIssue(owner, repo, item.number)
          : await this.github.getPullRequest(owner, repo, item.number);
        return {
          number: item.number,
          title: item.title,
          body: source.body || '',
          url: item.url,
          similarity: item.similarity,
        };
      })
    );

    const result = await this.llm.detectDuplicate(title, body, similarWithBody);
    const similarity = result.similarItems[0]?.similarity ?? 0;
    const relatedThreshold = Math.max(0, this.config.duplicateThreshold - 0.1);

    if (result.isDuplicate && similarity >= this.config.duplicateThreshold) {
      return { status: 'duplicate', similarity };
    }
    if (similarity >= relatedThreshold) {
      return { status: 'related', similarity };
    }

    return { status: 'distinct', similarity };
  }

  private scoreBacklogEntry(input: ScoringInputs): BacklogScore {
    const score = scoreBacklogItem({
      itemType: input.type,
      dedupeStatus: input.dedupeStatus,
      duplicateSimilarity: input.similarity,
      visionAlignment: input.visionAlignment,
      severityCounts: input.severityCounts,
      reviewComplexity: input.reviewComplexity,
    });
    return score;
  }

  /**
   * Find similar issues using embeddings
   */
  private async findSimilarIssues(
    owner: string,
    repo: string,
    embedding: number[],
    excludeNumber: number,
    state: 'open' | 'closed' | 'all' = 'all'
  ): Promise<SimilarItem[]> {
    const similarFromDb = await this.storage.findSimilar(
      embedding,
      this.config.duplicateThreshold,
      10
    );

    if (similarFromDb.length > 0) {
      return similarFromDb.filter(item => item.number !== excludeNumber && item.type === 'issue');
    }

    const issues = await this.github.getIssues(owner, repo, state);
    const similarities: SimilarItem[] = [];

    for (const issue of issues) {
      if (issue.number === excludeNumber) {
        continue;
      }

      const issueText = `${issue.title}\n\n${issue.body || ''}`;
      const issueEmbedding = await this.llm.generateEmbedding(issueText);
      const similarity = LLMService.cosineSimilarity(embedding, issueEmbedding);

      if (similarity >= this.config.duplicateThreshold) {
        similarities.push({
          number: issue.number,
          title: issue.title,
          url: issue.html_url,
          similarity,
          type: 'issue',
        });
      }

      await this.storage.storeEmbedding(`issue-${issue.number}`, issueEmbedding);
    }

    return similarities.sort((a, b) => b.similarity - a.similarity).slice(0, 10);
  }

  /**
   * Find similar PRs using embeddings
   */
  private async findSimilarPrs(
    owner: string,
    repo: string,
    embedding: number[],
    excludeNumber: number,
    state: 'open' | 'closed' | 'all' = 'all'
  ): Promise<SimilarItem[]> {
    const similarFromDb = await this.storage.findSimilar(
      embedding,
      this.config.duplicateThreshold,
      10
    );

    if (similarFromDb.length > 0) {
      return similarFromDb.filter(item => item.number !== excludeNumber && item.type === 'pr');
    }

    const prs = await this.github.getPullRequests(owner, repo, state);
    const similarities: SimilarItem[] = [];

    for (const pr of prs) {
      if (pr.number === excludeNumber) {
        continue;
      }

      const prText = `${pr.title}\n\n${pr.body || ''}`;
      const prEmbedding = await this.llm.generateEmbedding(prText);
      const similarity = LLMService.cosineSimilarity(embedding, prEmbedding);

      if (similarity >= this.config.duplicateThreshold) {
        similarities.push({
          number: pr.number,
          title: pr.title,
          url: pr.html_url,
          similarity,
          type: 'pr',
        });
      }

      await this.storage.storeEmbedding(`pr-${pr.head.sha}`, prEmbedding);
    }

    return similarities.sort((a, b) => b.similarity - a.similarity).slice(0, 10);
  }

  /**
   * Format duplicate detection comment
   */
  private formatDuplicateComment(result: any, type: 'issue' | 'pr'): string {
    const emoji = type === 'issue' ? 'üîç' : 'üîÄ';
    let comment = `${emoji} **Potential Duplicate Detected**\n\n`;
    comment += `This ${type} appears to be similar to:\n\n`;

    for (const item of result.similarItems) {
      const percentage = (item.similarity * 100).toFixed(1);
      comment += `- [#${item.number}](${item.url}) - ${item.title} (${percentage}% similar)\n`;
    }

    comment += `\n**Analysis:**\n${result.reasoning}\n\n`;
    comment += `---\n`;
    comment += `*This analysis was generated by [PRism](https://github.com/danhdox/prism) AI triage.*`;

    return comment;
  }

  /**
   * Format PR review comment
   */
  private formatReviewComment(review: any): string {
    let comment = `## ü§ñ AI Code Review\n\n`;
    comment += `**Summary:** ${review.summary}\n\n`;

    if (review.findings.length > 0) {
      comment += `### Findings\n\n`;

      const grouped = {
        issue: review.findings.filter((f: any) => f.type === 'issue'),
        suggestion: review.findings.filter((f: any) => f.type === 'suggestion'),
        praise: review.findings.filter((f: any) => f.type === 'praise'),
        question: review.findings.filter((f: any) => f.type === 'question'),
      };

      if (grouped.issue.length > 0) {
        comment += `#### ‚ö†Ô∏è Issues\n`;
        for (const finding of grouped.issue) {
          comment += this.formatFinding(finding);
        }
        comment += `\n`;
      }

      if (grouped.suggestion.length > 0) {
        comment += `#### üí° Suggestions\n`;
        for (const finding of grouped.suggestion) {
          comment += this.formatFinding(finding);
        }
        comment += `\n`;
      }

      if (grouped.praise.length > 0) {
        comment += `#### ‚ú® Highlights\n`;
        for (const finding of grouped.praise) {
          comment += this.formatFinding(finding);
        }
        comment += `\n`;
      }

      if (grouped.question.length > 0) {
        comment += `#### ‚ùì Questions\n`;
        for (const finding of grouped.question) {
          comment += this.formatFinding(finding);
        }
        comment += `\n`;
      }
    }

    comment += `**Estimated Complexity:** ${review.estimatedComplexity}\n\n`;

    if (review.suggestedLabels.length > 0) {
      comment += `**Suggested Labels:** ${review.suggestedLabels.map((l: string) => `\`${l}\``).join(', ')}\n\n`;
    }

    comment += `---\n`;
    comment += `*This review was generated by [PRism](https://github.com/danhdox/prism) AI triage.*`;

    return comment;
  }

  /**
   * Format a single finding
   */
  private formatFinding(finding: any): string {
    const severityEmoji: Record<string, string> = {
      critical: 'üî¥',
      major: 'üü†',
      minor: 'üü°',
      info: 'üîµ',
    };

    let text = `- ${severityEmoji[finding.severity] || '‚ö™'} **${finding.title}**\n`;
    text += `  ${finding.description}\n`;

    if (finding.file) {
      text += `  üìÅ \`${finding.file}\``;
      if (finding.line) {
        text += `:${finding.line}`;
      }
      text += `\n`;
    }

    return text;
  }
}
